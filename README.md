# kernel-exploit-factory

Keep updating......

Linux kernel CVE exploit analysis report and relative debug environment. You don't need to compile Linux kernel and configure your environment anymore. 

This repository is to extract all Linux kernel exploit and relative debug environment. You can use Qemu to boot the kernel and test the exploit.

---

## Example

```bash
# Eg, test CVE-2017-11176, finally you levate privileges and get the shell
john@john-virtual-machine:~/Desktop/kernel-exploit-factory/CVE-2017-11176$ ./start.sh 
chmod: /dev/csaw: No such file or directory
ifconfig: SIOCSIFADDR: No such device
route: SIOCADDRT: No such device
/ $ uname -a
Linux (none) 4.11.9 #1 SMP Sat Feb 20 21:52:39 CST 2021 x86_64 GNU/Linux
/ $ id
uid=1000(chal) gid=1000(chal) groups=1000(chal)
/ $ cd exp
/exp $ ./exp-slab-4119
[*] sk_rmem_alloc > sk_rcvbuf ==> ok
[*] mq_notify start
[*] wake up thread 1
... ...
/exp # id
uid=0(root) gid=0(root)
/exp # 
```

---

## Catalog

1. CVE-2015-8550
2. CVE-2016-9793
3. 4-20-BPF-integer
4. CVE-2017-5123
5. CVE-2017-6074
6. CVE-2017-7308
7. CVE-2017-8890
8. CVE-2017-11176
9. CVE-2017-16995
10. CVE-2017-1000112
11. CVE-2018-5333
12. CVE-2019-9213 & CVE-2019-8956
13. CVE-2019-15666
14. CVE-2020-8835
15. CVE-2020-27194
16. CVE-2021-3156
17. CVE-2021-31440
18. CVE-2021-3490
19. CVE-2021-22555
20. CVE-2021-42008
21. CVE-2021-43267

---

## Detail

#### 1.CVE-2015-8550

[writeup](https://blog.csdn.net/panhewu9919/article/details/100891770) 

**Test version**: Linux-4.19.65

**Protection**: 开启kaslr/SMEP，未开启SMAP。

**Vulnerability**: gcc 编译优化导致的**Double-Fetch漏洞**，可直接劫持控制流。

#### 2. CVE-2016-9793

[writeup](https://blog.csdn.net/panhewu9919/article/details/120164051) 

**Test version**: Linux-4.8.13

**Protection**: 未开 KASLR/SMAP/SMEP。伪造的[skb_shared_info](https://elixir.bootlin.com/linux/v4.8.13/source/include/linux/skbuff.h#L414)结构在用户空间，显然不能绕过SMAP。

**Vulnerability**: `net/core/sock.c`中的 [sock_setsockopt()](https://elixir.bootlin.com/linux/v4.8.13/source/net/core/sock.c#L658) 函数**错误处理负值**，导致 `sk_sndbuf` 和 `sk_rcvbuf`取值为负。调用`write`时将`skb->head`和`skb->end`设置错误，最后调用`close`释放时会访问用户空间报错。用户空间地址`0xfffffed0`处伪造[skb_shared_info](https://elixir.bootlin.com/linux/v4.8.13/source/include/linux/skbuff.h#L414)结构，通过`skb_shared_info)->destructor_arg->callback` 劫持控制流。

#### 3. 4-20-BPF-integer

[writeup](https://www.cnblogs.com/bsauce/p/11560224.html) 

**Test version**: Linux-4.20.0-rc3

**Protection**: 开启SMEP，未开启kaslr/SMAP。

**Vulnerability**: Linux ebpf 模块中`queue_stack_map_alloc()`中**整数溢出**漏洞，导致堆溢出。修改虚表指针劫持控制流到`xchg eax, esp`。

#### 4.CVE-2017-5123

[writeup](https://www.jianshu.com/p/90a040114188) 

**Test version**: Linux 4.14-rc4

**Protection**: 开启 SMEP / SMAP，关闭KASLR。

**Vulnerability**: `/kernel/exit.c`中的`waitid`的实现，在调用`unsafe_put_user()`将内核数据拷贝到用户空间地址时，没有调用`access_ok()`检测用户空间地址的合法性，导致实际可以往内核空间地址拷贝数据。 **waitid未检测用户地址合法性 导致 null 任意地址写**。可执行0地址shellcode 或 覆盖某猜测范围的cred 来提权。

#### 5.CVE-2017-6074

[writeup](https://bsauce.github.io/2021/09/17/CVE-2017-6074/)      [reference](https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-6074)

**Test version**: Linux-4.9.12

**Protection**: 开启SMEP/SMAP，关闭kASLR。

**Vulnerability**: Linux内核IP V6协议簇的DCCP（数据报拥塞控制协议），`net/dccp/input.c`中的 [dccp_rcv_state_process()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/input.c#L574) 函数，在`LISTEN`状态下错误处理 `DCCP_PKT_REQUEST` 包数据结构，用户采用`IPV6_RECVPKTINFO`选项调用`setsockopt()`时会触发**`sk_buff`结构的 Double-Free**。利用方式类似CVE-2016-8655。第一次触发漏洞，堆喷伪造`po->rx_ring->prb_bdqc->retire_blk_timer`结构，执行`native_write_cr4(0x406e0)`来关闭SMEP/SMAP；第二次触发漏洞，堆喷伪造``skb-> ... ->destructor_arg`结构，执行`commit_creds(prepare_kernel_cred(0))`来提权。

#### 6.CVE-2017-7308

[writeup](https://www.jianshu.com/p/b53862cd64a6)      [reference](https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308)

**Test version**: Linux-4.10.6

**Protection**: 开启 SMEP / SMAP，关闭KASLR。

**Vulnerability**: `net/packet/af_packet.c`中的[`packet_set_ring()`](https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/af_packet.c#L4181)函数没有正确检查块size，长度判断条件错误，导致**堆溢出**，需要`CAP_NET_RAW `权限。两次劫持函数指针，先关闭SMEP/SMAP防护，再提权。

#### 7.CVE-2017-8890

[writeup](https://www.jianshu.com/p/699de662f567)      [reference](https://xz.aliyun.com/t/2383)

**Test version**: Linux-4.10.15

**Protection**: 开启SMEP，关闭kASLR、SMAP。

**Vulnerability**: `net/ipv4/inet_connection_sock.c`文件中的[`inet_csk_clone_lock()`](https://elixir.bootlin.com/linux/v4.10.15/source/net/ipv4/inet_connection_sock.c#L652)函数存在**Double-Free**漏洞。利用Double-Free来篡改RCU的回调函数指针，关闭SMEP并跳转到shellcode来修改cred。

#### 8.CVE-2017-11176

[writeup](https://www.jianshu.com/p/76041ec5c59f) 

**Test version**: Linux-4.11.9

**Protection**: 开启SMEP，关闭kASLR、SMAP。

**Vulnerability**: Linux内核中的POSIX消息队列的实现，`mq_notify()`函数没有把sock指针置为null，导致UAF。实际上是由于**竞争导致的Double-Free漏洞**，但竞态的时间可以无限延长。

#### 9.CVE-2017-16995

[writeup](https://www.cnblogs.com/bsauce/p/11583310.html) 

**Test version**: Linux-4.4.110

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: Linux ebpf 模块**整数扩展**问题，主要问题是二者寄存器值类型不同，导致check函数和真正的函数的执行方法不一致。本漏洞不包含堆栈攻击或控制流劫持，仅用系统调用数据进行提权，是Data-Oriented Attacks在linux内核上的一个典型应用。

#### 10. CVE-2017-1000112

[writeup](https://www.jianshu.com/p/1fa163fd5b82)  	  [reference](https://bbs.pediy.com/thread-265319.htm)

**Test version**: Linux-4.12.6

**Protection**: 开启SMEP，关闭SMAP/kaslr。

**Vulnerability**: `net/ipv4/ip_output.c` 中的[__ip_append_data()](https://elixir.bootlin.com/linux/v4.12.6/source/net/ipv4/ip_output.c#L910) 没有保证UDP报文处理的一致性，导致两次send报文时，可从UFO路径切换为non-UFO路径，导致**堆溢出**。利用时可通过覆盖`skb_shared_info->destructor_arg->callback`劫持控制流。

#### 11. CVE-2018-5333

[writeup](https://blog.csdn.net/panhewu9919/article/details/119153052)  

**Test version**: Linux-4.14.13

**Protection**: 开启SMEP，关闭SMAP/kaslr。

**Vulnerability**: `net/rds/rdma.c`中的 [`rds_cmsg_atomic()`](https://elixir.bootlin.com/linux/v4.14.13/source/net/rds/rdma.c#L788) 函数中忘记将`rm->atomic.op_active`置0，导致 [rds_atomic_free_op()](https://elixir.bootlin.com/linux/v4.14.13/source/net/rds/rdma.c#L474) ->  [set_page_dirty()](https://elixir.bootlin.com/linux/v4.14.13/source/mm/page-writeback.c#L2559) 引用`page->page_link`时发生 **`null-dereference` 漏洞**。在0地址伪造结构和函数指针，劫持控制流。

#### 12. CVE-2019-9213 & CVE-2019-8956

[CVE-2019-9213-writeup](https://blog.csdn.net/panhewu9919/article/details/118557802)    [CVE-2019-8956-writeup](https://blog.csdn.net/panhewu9919/article/details/118557844)    

**Test version**: Linux-4.20.0 32位

**Protection**: 开启SMEP，关闭SMAP/kaslr。

**Vulnerability**: 

- CVE-2019-9213：`mm/mmap.c`中的[`expand_downwards()`](https://elixir.bootlin.com/linux/v4.20.7/source/mm/mmap.c#L2413)对mmap最小地址的检查出错，对错误的task进行了capability检查，导致绕过了`mmap_min_addr`的限制，**逻辑漏洞**。利用`LD_DEBUG=help /bin/su 1>&%d`命令执行write操作，本来应检测exp的cred，结果错误检测了write进程的cred，就将低地址标记为特权可访问。只有32位系统能成功利用漏洞，原因不详。
- CVE-2019-8956：`net/sctp/socket.c`中的 [`sctp_sendmsg()`](https://elixir.bootlin.com/linux/v4.20.7/source/net/sctp/socket.c#L2025) 函数在处理`SCTP_SENDALL` flag时出现**空指针引用**漏洞。结合CVE-2019-9213，绕过`mmap_min_addr`的限制，可以mmap到低地址0xd4并伪造结构，劫持控制流。

#### 13. CVE-2019-15666

[writeup](https://bsauce.github.io/2021/09/14/CVE-2019-15666/)  	  [reference](https://github.com/riskeco/Lucky/blob/master/lucky0_RE.c)

**Test version**: Ubuntu 18.04（4.15.0-20-generic #21）

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: `net/xfrm/xfrm_user.c`中的 [verify_newpolicy_info()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1379) 错误处理了`dir`验证，导致[__xfrm_policy_unlink()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2202)中出现**越界访问**。漏洞原本是个越界减1，可以利用别的路径来构造UAF，可以往**空闲块上的8字节写null**。漏洞对象`xfrm_policy`位于`kmalloc-1024`，cred结构位于`kmalloc-192`。首先利用`setxattr+userfaultfd`在`policy0`周围都喷射`kmalloc-1024`堆块，释放`policy0`后同时释放喷射块，促使该slab释放后被c子进程的red复用，然后触发UAF 空闲块8字节NULL写来修改cred中的`gid/suid`，再将当前用户添加到sudoers，即可提权。

#### 14. CVE-2020-8835

[writeup](https://www.cnblogs.com/bsauce/p/14123111.html)  	  [reference](https://xz.aliyun.com/t/7690)

**Test version**: Linux-5.5.0

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: kernel/bpf/verifier.c没有正确将64位值转换为32位（直接取低32位），发生**整数截断**，使得BPF代码验证阶段和实际执行阶段不一致，导致越界读写。

#### 15. CVE-2020-27194

[writeup](https://www.jianshu.com/p/b6f11d8df37a)       [reference](https://github.com/willinin/CVE-2020-27194-exp)

**Test version**: Linux-5.8.14

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: eBPF验证程序中进行or操作时，`scalar32_min_max_or()`函数将64位的值赋值到32位的变量上，导致**整数截断**，进而错误计算了寄存器的范围，从而绕过bpf的检查，导致越界读写。

#### 16. CVE-2021-3156

[writeup](https://www.jianshu.com/p/18f36f1342b3)       [exploit](https://github.com/blasty/CVE-2021-3156)

**Test version**: Ubuntu 19.04、Sudo 1.8.27

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: sudo在处理命令行参数时，处理单个反斜杠结尾的命令时，发生逻辑错误，导致**堆溢出**。

#### 17. CVE-2021-31440

[writeup](https://bsauce.github.io/2021/06/09/CVE-2021-31440/)      [exploit](https://github.com/bsauce/kernel-exploit-factory/tree/main/CVE-2021-31440/exp)

**Test version**: Linux-5.11

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: eBPF模块—`kernel/bpf/verifier.c`的[`__reg_combine_64_into_32()`](https://elixir.bootlin.com/linux/v5.11.20/source/kernel/bpf/verifier.c#L1312) 函数，寄存器计算错误。利用verifier阶段与实际执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。

#### 18. CVE-2021-3490

[writeup](https://bsauce.github.io/2021/08/31/CVE-2021-3490/)      [exploit](https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490)

**Test version**: Linux-5.11  Linux-5.11.16

**Protection**: 开启SMEP/SMAP/kaslr。

**Vulnerability**: eBPF模块—`kernel/bpf/verifier.c`的按位操作（AND、OR 和 XOR）的 eBPF ALU32 边界跟踪没有正确更新 32 位边界，造成 Linux 内核中的越界读取和写入，从而导致任意代码执行。三个漏洞函数分别是 [scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7078) 、[scalar32_min_max_or()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7149)、[scalar32_min_max_xor()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7219)。利用verifier阶段与实际执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。

#### 19. CVE-2021-22555

[writeup](https://bsauce.github.io/2021/09/23/CVE-2021-22555/)      [exploit](https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c)

**Test version**: Linux-5.11.14

**Protection**: 开启KASLR/SMEP/SMAP。

**Vulnerability**: `net/netfilter/x_tables.c` 中 `Netfilter` 模块的`ip_tables`子模块， 当调用`setsockopt()`和选项`IPT_SO_SET_REPLACE`（或 `IP6T_SO_SET_REPLACE`）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 [xt_compat_match_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731) 函数时**堆溢出写 0 ，可转化为UAF**。攻击者可用于提权，或者从docker、k8s容器（[kubernetes](https://zhuanlan.zhihu.com/p/29232090)）中逃逸。需要`CAP_NET_ADMIN`权限，或者支持`user+network`命名空间。

#### 20. CVE-2021-42008

[writeup](https://bsauce.github.io/2021/12/06/CVE-2021-43267/)      [reference](https://haxx.in/posts/pwning-tipc/)

**Test version**: Linux-5.13.12

**Protection**: 开启KASLR / SMEP / SMAP / PTI。

**Vulnerability**: `drivers/net/hamradio/6pack.c`中 [decode_data()](https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L826) 函数存在**堆溢出**，用户需具备 `CAP_NET_ADMIN` 权限。[sixpack_decode()](https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L962) 可多次调用 [decode_data()](https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L826) ，对输入进行解码并保存到 [sixpack->cooked_buf](https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L98) ，`sixpack->rx_count_cooked`成员充当访问 `sixpack->cooked_buf` 的下标，确定写入解码字节的目标偏移。问题是如果多次调用`decode_data()`，`rx_count_cooked`就会一直递增，直到超过 `cooked_buf` 的长度（400字节），导致越界写。参考[Linux内核中利用msg_msg结构实现任意地址读写](https://www.anquanke.com/post/id/252558)构造越界读和任意地址写，篡改`modprobe_path`提权，缺点是得用到`userfaultfd`，且绕不开 `CAP_NET_ADMIN` 的槛。

#### 21. CVE-2021-43267

[writeup](https://bsauce.github.io/2021/12/06/CVE-2021-43267/)      [reference](https://haxx.in/posts/pwning-tipc/)

**Test version**: Linux-5.14.15

**Protection**: 开启KASLR/SMEP/SMAP。

**Vulnerability**: 漏洞位于 `net/tipc/crypto.c` 文件，TIPC（Transparent Inter-Process Communication）集群内通信协议中对 `MSG_CRYPTO` 类型的消息长度验证出错，导致**堆溢出**。[tipc_crypto_key_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2281) 函数中，TIPC消息（[tipc_msg](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.h#L148)结构）的数据部分指向`MSG_CRYPTO`消息（[tipc_aead_key](https://elixir.bootlin.com/linux/v5.14.15/source/include/uapi/linux/tipc.h#L241)结构），在分配`tipc_aead_key` 空间并拷贝 `tipc_aead_key->key` 时，未校验`tipc_aead_key->keylen`的有效性，导致拷贝越界。只对TIPC消息的 `header size` 和 `msg size` 进行检查，却没有对 `MSG_CRYPTO`消息的`tipc_aead_key->keylen`进行检查。利用 `elastic object` 泄露内核基址，并篡改`tty_struct->tty_operations.ioctl` 指向任意写gadget （`mov   QWORD PTR [rdx],rsi`），篡改 `modprobe_path` 提权。























